{"question": "How would you test index?", "answer": "Here's the implementation:\n```python\ndef index():\n    if request.method == \"POST\":\n        api_key = request.form.get(\"api_key\")\n        num_slides = request.form.get(\"num_slides\")\n        file = request.files[\"pdf_file\"]\n\n        if not (api_key and num_slides and file):\n            return \"Missing required input.\"\n\n        # Save PDF\n        pdf_filename = f\"{uuid.uuid4().hex}.pdf\"\n        pdf_path = os.path.join(UPLOAD_FOLDER, pdf_filename)\n        file.save(pdf_path)\n\n        # Generate PowerPoint\n        try:\n            result = subprocess.run(\n                [\n                    \"python\", \"pdf2ppt.py\",\n                    api_key, pdf_path, num_slides\n                ],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            return f\"<pre>Error:\\n{e.stderr}</pre>\"\n\n        pptx_filename = os.path.splitext(os.path.basename(pdf_filename))[0] + \"_summary.pptx\"\n        pptx_path = os.path.join(\".\", pptx_filename)\n        if not os.path.exists(pptx_path):\n            pptx_path = os.path.join(\"output\", pptx_filename)  # if your script saves there\n\n        return send_file(pptx_path, as_attachment=True)\n\n    return render_template(\"index.html\")\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\app.py\n\n- Function: index", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\app.py", "start_line": 21, "end_line": 56, "code": "def index():\n    if request.method == \"POST\":\n        api_key = request.form.get(\"api_key\")\n        num_slides = request.form.get(\"num_slides\")\n        file = request.files[\"pdf_file\"]\n\n        if not (api_key and num_slides and file):\n            return \"Missing required input.\"\n\n        # Save PDF\n        pdf_filename = f\"{uuid.uuid4().hex}.pdf\"\n        pdf_path = os.path.join(UPLOAD_FOLDER, pdf_filename)\n        file.save(pdf_path)\n\n        # Generate PowerPoint\n        try:\n            result = subprocess.run(\n                [\n                    \"python\", \"pdf2ppt.py\",\n                    api_key, pdf_path, num_slides\n                ],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            return f\"<pre>Error:\\n{e.stderr}</pre>\"\n\n        pptx_filename = os.path.splitext(os.path.basename(pdf_filename))[0] + \"_summary.pptx\"\n        pptx_path = os.path.join(\".\", pptx_filename)\n        if not os.path.exists(pptx_path):\n            pptx_path = os.path.join(\"output\", pptx_filename)  # if your script saves there\n\n        return send_file(pptx_path, as_attachment=True)\n\n    return render_template(\"index.html\")", "imports": [], "class_name": null, "function_name": "index", "docstring": null, "variables": ["pdf_filename", "pdf_path", "file", "api_key", "pptx_filename", "num_slides", "pptx_path", "result"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What are the side effects of calling index?", "answer": "Here's the implementation:\n```python\ndef index():\n    if request.method == \"POST\":\n        api_key = request.form.get(\"api_key\")\n        num_slides = request.form.get(\"num_slides\")\n        file = request.files[\"pdf_file\"]\n\n        if not (api_key and num_slides and file):\n            return \"Missing required input.\"\n\n        # Save PDF\n        pdf_filename = f\"{uuid.uuid4().hex}.pdf\"\n        pdf_path = os.path.join(UPLOAD_FOLDER, pdf_filename)\n        file.save(pdf_path)\n\n        # Generate PowerPoint\n        try:\n            result = subprocess.run(\n                [\n                    \"python\", \"pdf2ppt.py\",\n                    api_key, pdf_path, num_slides\n                ],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            return f\"<pre>Error:\\n{e.stderr}</pre>\"\n\n        pptx_filename = os.path.splitext(os.path.basename(pdf_filename))[0] + \"_summary.pptx\"\n        pptx_path = os.path.join(\".\", pptx_filename)\n        if not os.path.exists(pptx_path):\n            pptx_path = os.path.join(\"output\", pptx_filename)  # if your script saves there\n\n        return send_file(pptx_path, as_attachment=True)\n\n    return render_template(\"index.html\")\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\app.py\n\n- Function: index", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\app.py", "start_line": 21, "end_line": 56, "code": "def index():\n    if request.method == \"POST\":\n        api_key = request.form.get(\"api_key\")\n        num_slides = request.form.get(\"num_slides\")\n        file = request.files[\"pdf_file\"]\n\n        if not (api_key and num_slides and file):\n            return \"Missing required input.\"\n\n        # Save PDF\n        pdf_filename = f\"{uuid.uuid4().hex}.pdf\"\n        pdf_path = os.path.join(UPLOAD_FOLDER, pdf_filename)\n        file.save(pdf_path)\n\n        # Generate PowerPoint\n        try:\n            result = subprocess.run(\n                [\n                    \"python\", \"pdf2ppt.py\",\n                    api_key, pdf_path, num_slides\n                ],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            return f\"<pre>Error:\\n{e.stderr}</pre>\"\n\n        pptx_filename = os.path.splitext(os.path.basename(pdf_filename))[0] + \"_summary.pptx\"\n        pptx_path = os.path.join(\".\", pptx_filename)\n        if not os.path.exists(pptx_path):\n            pptx_path = os.path.join(\"output\", pptx_filename)  # if your script saves there\n\n        return send_file(pptx_path, as_attachment=True)\n\n    return render_template(\"index.html\")", "imports": [], "class_name": null, "function_name": "index", "docstring": null, "variables": ["pdf_filename", "pdf_path", "file", "api_key", "pptx_filename", "num_slides", "pptx_path", "result"]}, "question_type": "function", "difficulty": "hard", "metadata": null}
{"question": "What is the time complexity of index?", "answer": "Here's the implementation:\n```python\ndef index():\n    if request.method == \"POST\":\n        api_key = request.form.get(\"api_key\")\n        num_slides = request.form.get(\"num_slides\")\n        file = request.files[\"pdf_file\"]\n\n        if not (api_key and num_slides and file):\n            return \"Missing required input.\"\n\n        # Save PDF\n        pdf_filename = f\"{uuid.uuid4().hex}.pdf\"\n        pdf_path = os.path.join(UPLOAD_FOLDER, pdf_filename)\n        file.save(pdf_path)\n\n        # Generate PowerPoint\n        try:\n            result = subprocess.run(\n                [\n                    \"python\", \"pdf2ppt.py\",\n                    api_key, pdf_path, num_slides\n                ],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            return f\"<pre>Error:\\n{e.stderr}</pre>\"\n\n        pptx_filename = os.path.splitext(os.path.basename(pdf_filename))[0] + \"_summary.pptx\"\n        pptx_path = os.path.join(\".\", pptx_filename)\n        if not os.path.exists(pptx_path):\n            pptx_path = os.path.join(\"output\", pptx_filename)  # if your script saves there\n\n        return send_file(pptx_path, as_attachment=True)\n\n    return render_template(\"index.html\")\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\app.py\n\n- Function: index", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\app.py", "start_line": 21, "end_line": 56, "code": "def index():\n    if request.method == \"POST\":\n        api_key = request.form.get(\"api_key\")\n        num_slides = request.form.get(\"num_slides\")\n        file = request.files[\"pdf_file\"]\n\n        if not (api_key and num_slides and file):\n            return \"Missing required input.\"\n\n        # Save PDF\n        pdf_filename = f\"{uuid.uuid4().hex}.pdf\"\n        pdf_path = os.path.join(UPLOAD_FOLDER, pdf_filename)\n        file.save(pdf_path)\n\n        # Generate PowerPoint\n        try:\n            result = subprocess.run(\n                [\n                    \"python\", \"pdf2ppt.py\",\n                    api_key, pdf_path, num_slides\n                ],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            return f\"<pre>Error:\\n{e.stderr}</pre>\"\n\n        pptx_filename = os.path.splitext(os.path.basename(pdf_filename))[0] + \"_summary.pptx\"\n        pptx_path = os.path.join(\".\", pptx_filename)\n        if not os.path.exists(pptx_path):\n            pptx_path = os.path.join(\"output\", pptx_filename)  # if your script saves there\n\n        return send_file(pptx_path, as_attachment=True)\n\n    return render_template(\"index.html\")", "imports": [], "class_name": null, "function_name": "index", "docstring": null, "variables": ["pdf_filename", "pdf_path", "file", "api_key", "pptx_filename", "num_slides", "pptx_path", "result"]}, "question_type": "function", "difficulty": "hard", "metadata": null}
{"question": "How does parse_args work?", "answer": "Here's the implementation:\n```python\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"GEMINI_API_KEY\", help=\"Your Gemini API Key\")\n    parser.add_argument(\"PDF_PATH\", help=\"Path to input PDF file\")\n    parser.add_argument(\"num_slides\", type=int, help=\"Number of slides to generate\")\n    return parser.parse_args()\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: parse_args", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 22, "end_line": 27, "code": "def parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"GEMINI_API_KEY\", help=\"Your Gemini API Key\")\n    parser.add_argument(\"PDF_PATH\", help=\"Path to input PDF file\")\n    parser.add_argument(\"num_slides\", type=int, help=\"Number of slides to generate\")\n    return parser.parse_args()", "imports": [], "class_name": null, "function_name": "parse_args", "docstring": null, "variables": ["parser"]}, "question_type": "function", "difficulty": "easy", "metadata": null}
{"question": "What is the return type of parse_args?", "answer": "Here's the implementation:\n```python\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"GEMINI_API_KEY\", help=\"Your Gemini API Key\")\n    parser.add_argument(\"PDF_PATH\", help=\"Path to input PDF file\")\n    parser.add_argument(\"num_slides\", type=int, help=\"Number of slides to generate\")\n    return parser.parse_args()\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: parse_args", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 22, "end_line": 27, "code": "def parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"GEMINI_API_KEY\", help=\"Your Gemini API Key\")\n    parser.add_argument(\"PDF_PATH\", help=\"Path to input PDF file\")\n    parser.add_argument(\"num_slides\", type=int, help=\"Number of slides to generate\")\n    return parser.parse_args()", "imports": [], "class_name": null, "function_name": "parse_args", "docstring": null, "variables": ["parser"]}, "question_type": "function", "difficulty": "hard", "metadata": null}
{"question": "What is the time complexity of parse_args?", "answer": "Here's the implementation:\n```python\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"GEMINI_API_KEY\", help=\"Your Gemini API Key\")\n    parser.add_argument(\"PDF_PATH\", help=\"Path to input PDF file\")\n    parser.add_argument(\"num_slides\", type=int, help=\"Number of slides to generate\")\n    return parser.parse_args()\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: parse_args", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 22, "end_line": 27, "code": "def parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"GEMINI_API_KEY\", help=\"Your Gemini API Key\")\n    parser.add_argument(\"PDF_PATH\", help=\"Path to input PDF file\")\n    parser.add_argument(\"num_slides\", type=int, help=\"Number of slides to generate\")\n    return parser.parse_args()", "imports": [], "class_name": null, "function_name": "parse_args", "docstring": null, "variables": ["parser"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What are the side effects of calling extract_pdf_text?", "answer": "Here's the implementation:\n```python\ndef extract_pdf_text(path, max_pages=10) -> str:\n    doc = pymupdf.open(path)\n    text = \"\"\n    for page in doc[:max_pages]:\n        text += page.get_text()\n    return text\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: extract_pdf_text", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 30, "end_line": 35, "code": "def extract_pdf_text(path, max_pages=10) -> str:\n    doc = pymupdf.open(path)\n    text = \"\"\n    for page in doc[:max_pages]:\n        text += page.get_text()\n    return text", "imports": [], "class_name": null, "function_name": "extract_pdf_text", "docstring": null, "variables": ["doc", "page", "text"]}, "question_type": "function", "difficulty": "hard", "metadata": null}
{"question": "How does extract_pdf_text work?", "answer": "Here's the implementation:\n```python\ndef extract_pdf_text(path, max_pages=10) -> str:\n    doc = pymupdf.open(path)\n    text = \"\"\n    for page in doc[:max_pages]:\n        text += page.get_text()\n    return text\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: extract_pdf_text", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 30, "end_line": 35, "code": "def extract_pdf_text(path, max_pages=10) -> str:\n    doc = pymupdf.open(path)\n    text = \"\"\n    for page in doc[:max_pages]:\n        text += page.get_text()\n    return text", "imports": [], "class_name": null, "function_name": "extract_pdf_text", "docstring": null, "variables": ["doc", "page", "text"]}, "question_type": "function", "difficulty": "easy", "metadata": null}
{"question": "What is the return type of extract_pdf_text?", "answer": "Here's the implementation:\n```python\ndef extract_pdf_text(path, max_pages=10) -> str:\n    doc = pymupdf.open(path)\n    text = \"\"\n    for page in doc[:max_pages]:\n        text += page.get_text()\n    return text\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: extract_pdf_text", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 30, "end_line": 35, "code": "def extract_pdf_text(path, max_pages=10) -> str:\n    doc = pymupdf.open(path)\n    text = \"\"\n    for page in doc[:max_pages]:\n        text += page.get_text()\n    return text", "imports": [], "class_name": null, "function_name": "extract_pdf_text", "docstring": null, "variables": ["doc", "page", "text"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "How does extract_images_from_pdf work?", "answer": "This function is documented as: Only extract (png,jpg) images, not vector images (eps) from pdf\nmin_width in points, 72 pts = 1 inch\n\nHere's the implementation:\n```python\ndef extract_images_from_pdf(pdf_path, output_folder='images', min_width=72, min_height=72)-> list[str]:\n    '''\n    Only extract (png,jpg) images, not vector images (eps) from pdf\n    min_width in points, 72 pts = 1 inch\n    '''\n    os.makedirs(output_folder, exist_ok=True)\n    doc = pymupdf.open(pdf_path)\n    image_paths = []\n\n    for page_num, page in enumerate(doc):\n        for img_index, img in enumerate(page.get_images(full=True)):\n            xref = img[0]  # cross-reference number, int\n            rects = page.get_image_rects(xref)\n            if not rects:\n                continue\n            # For each on-page occurrence, keep it if big enough\n            for rect in rects:\n                if rect.width < min_width or rect.height < min_height:\n                    continue\n\n                # Extract the pixmap\n                pix = pymupdf.Pixmap(doc, xref)\n            \n                img_path = os.path.join(output_folder, f\"page{page_num+1}_img{img_index+1}.jpg\")\n                pix.save(img_path)\n                pix = None\n                image_paths.append(img_path)\n\n    return image_paths  # list of all saved image paths\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: extract_images_from_pdf", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 38, "end_line": 66, "code": "def extract_images_from_pdf(pdf_path, output_folder='images', min_width=72, min_height=72)-> list[str]:\n    '''\n    Only extract (png,jpg) images, not vector images (eps) from pdf\n    min_width in points, 72 pts = 1 inch\n    '''\n    os.makedirs(output_folder, exist_ok=True)\n    doc = pymupdf.open(pdf_path)\n    image_paths = []\n\n    for page_num, page in enumerate(doc):\n        for img_index, img in enumerate(page.get_images(full=True)):\n            xref = img[0]  # cross-reference number, int\n            rects = page.get_image_rects(xref)\n            if not rects:\n                continue\n            # For each on-page occurrence, keep it if big enough\n            for rect in rects:\n                if rect.width < min_width or rect.height < min_height:\n                    continue\n\n                # Extract the pixmap\n                pix = pymupdf.Pixmap(doc, xref)\n            \n                img_path = os.path.join(output_folder, f\"page{page_num+1}_img{img_index+1}.jpg\")\n                pix.save(img_path)\n                pix = None\n                image_paths.append(img_path)\n\n    return image_paths  # list of all saved image paths", "imports": [], "class_name": null, "function_name": "extract_images_from_pdf", "docstring": "Only extract (png,jpg) images, not vector images (eps) from pdf\nmin_width in points, 72 pts = 1 inch", "variables": ["doc", "xref", "pix", "page_num", "img", "img_path", "image_paths", "rect", "page", "img_index", "rects"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What are the edge cases for extract_images_from_pdf?", "answer": "This function is documented as: Only extract (png,jpg) images, not vector images (eps) from pdf\nmin_width in points, 72 pts = 1 inch\n\nHere's the implementation:\n```python\ndef extract_images_from_pdf(pdf_path, output_folder='images', min_width=72, min_height=72)-> list[str]:\n    '''\n    Only extract (png,jpg) images, not vector images (eps) from pdf\n    min_width in points, 72 pts = 1 inch\n    '''\n    os.makedirs(output_folder, exist_ok=True)\n    doc = pymupdf.open(pdf_path)\n    image_paths = []\n\n    for page_num, page in enumerate(doc):\n        for img_index, img in enumerate(page.get_images(full=True)):\n            xref = img[0]  # cross-reference number, int\n            rects = page.get_image_rects(xref)\n            if not rects:\n                continue\n            # For each on-page occurrence, keep it if big enough\n            for rect in rects:\n                if rect.width < min_width or rect.height < min_height:\n                    continue\n\n                # Extract the pixmap\n                pix = pymupdf.Pixmap(doc, xref)\n            \n                img_path = os.path.join(output_folder, f\"page{page_num+1}_img{img_index+1}.jpg\")\n                pix.save(img_path)\n                pix = None\n                image_paths.append(img_path)\n\n    return image_paths  # list of all saved image paths\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: extract_images_from_pdf", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 38, "end_line": 66, "code": "def extract_images_from_pdf(pdf_path, output_folder='images', min_width=72, min_height=72)-> list[str]:\n    '''\n    Only extract (png,jpg) images, not vector images (eps) from pdf\n    min_width in points, 72 pts = 1 inch\n    '''\n    os.makedirs(output_folder, exist_ok=True)\n    doc = pymupdf.open(pdf_path)\n    image_paths = []\n\n    for page_num, page in enumerate(doc):\n        for img_index, img in enumerate(page.get_images(full=True)):\n            xref = img[0]  # cross-reference number, int\n            rects = page.get_image_rects(xref)\n            if not rects:\n                continue\n            # For each on-page occurrence, keep it if big enough\n            for rect in rects:\n                if rect.width < min_width or rect.height < min_height:\n                    continue\n\n                # Extract the pixmap\n                pix = pymupdf.Pixmap(doc, xref)\n            \n                img_path = os.path.join(output_folder, f\"page{page_num+1}_img{img_index+1}.jpg\")\n                pix.save(img_path)\n                pix = None\n                image_paths.append(img_path)\n\n    return image_paths  # list of all saved image paths", "imports": [], "class_name": null, "function_name": "extract_images_from_pdf", "docstring": "Only extract (png,jpg) images, not vector images (eps) from pdf\nmin_width in points, 72 pts = 1 inch", "variables": ["doc", "xref", "pix", "page_num", "img", "img_path", "image_paths", "rect", "page", "img_index", "rects"]}, "question_type": "function", "difficulty": "easy", "metadata": null}
{"question": "How would you test extract_images_from_pdf?", "answer": "This function is documented as: Only extract (png,jpg) images, not vector images (eps) from pdf\nmin_width in points, 72 pts = 1 inch\n\nHere's the implementation:\n```python\ndef extract_images_from_pdf(pdf_path, output_folder='images', min_width=72, min_height=72)-> list[str]:\n    '''\n    Only extract (png,jpg) images, not vector images (eps) from pdf\n    min_width in points, 72 pts = 1 inch\n    '''\n    os.makedirs(output_folder, exist_ok=True)\n    doc = pymupdf.open(pdf_path)\n    image_paths = []\n\n    for page_num, page in enumerate(doc):\n        for img_index, img in enumerate(page.get_images(full=True)):\n            xref = img[0]  # cross-reference number, int\n            rects = page.get_image_rects(xref)\n            if not rects:\n                continue\n            # For each on-page occurrence, keep it if big enough\n            for rect in rects:\n                if rect.width < min_width or rect.height < min_height:\n                    continue\n\n                # Extract the pixmap\n                pix = pymupdf.Pixmap(doc, xref)\n            \n                img_path = os.path.join(output_folder, f\"page{page_num+1}_img{img_index+1}.jpg\")\n                pix.save(img_path)\n                pix = None\n                image_paths.append(img_path)\n\n    return image_paths  # list of all saved image paths\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: extract_images_from_pdf", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 38, "end_line": 66, "code": "def extract_images_from_pdf(pdf_path, output_folder='images', min_width=72, min_height=72)-> list[str]:\n    '''\n    Only extract (png,jpg) images, not vector images (eps) from pdf\n    min_width in points, 72 pts = 1 inch\n    '''\n    os.makedirs(output_folder, exist_ok=True)\n    doc = pymupdf.open(pdf_path)\n    image_paths = []\n\n    for page_num, page in enumerate(doc):\n        for img_index, img in enumerate(page.get_images(full=True)):\n            xref = img[0]  # cross-reference number, int\n            rects = page.get_image_rects(xref)\n            if not rects:\n                continue\n            # For each on-page occurrence, keep it if big enough\n            for rect in rects:\n                if rect.width < min_width or rect.height < min_height:\n                    continue\n\n                # Extract the pixmap\n                pix = pymupdf.Pixmap(doc, xref)\n            \n                img_path = os.path.join(output_folder, f\"page{page_num+1}_img{img_index+1}.jpg\")\n                pix.save(img_path)\n                pix = None\n                image_paths.append(img_path)\n\n    return image_paths  # list of all saved image paths", "imports": [], "class_name": null, "function_name": "extract_images_from_pdf", "docstring": "Only extract (png,jpg) images, not vector images (eps) from pdf\nmin_width in points, 72 pts = 1 inch", "variables": ["doc", "xref", "pix", "page_num", "img", "img_path", "image_paths", "rect", "page", "img_index", "rects"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What is the return type of generate_slide_content?", "answer": "Here's the implementation:\n```python\ndef generate_slide_content(text: str, model='gemini-2.0-flash') -> str:\n    prompt = f\"\"\"\n    You are an expert scientific summarizer.\n    Summarize the following academic paper into no more than **{num_slides}** clean PowerPoint slides.\n    You are welcome to use less slides. \n    More advanced expert can use less slides and less bullets to cover key points.\n    For each slide output exactly:\n\n    Slide 1:\n    Title: <one short sentence>\n    Bullets:\n    - <up to 5 bullets, max 16 words each>\n    - <…>\n    - <…>\n\n    Mark “[[FIGURE+number or letter]]” wherever a figure from the paper should be placed (we’ll move it later).\n    Do not include any other words, symbols, or slide numbers.\n\n    Paper:\n    {text[:10000]}  # truncate to avoid token overflow\n    \"\"\"\n    response = client.models.generate_content(model=model, contents= prompt)\n    return response.text\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: generate_slide_content", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 69, "end_line": 91, "code": "def generate_slide_content(text: str, model='gemini-2.0-flash') -> str:\n    prompt = f\"\"\"\n    You are an expert scientific summarizer.\n    Summarize the following academic paper into no more than **{num_slides}** clean PowerPoint slides.\n    You are welcome to use less slides. \n    More advanced expert can use less slides and less bullets to cover key points.\n    For each slide output exactly:\n\n    Slide 1:\n    Title: <one short sentence>\n    Bullets:\n    - <up to 5 bullets, max 16 words each>\n    - <…>\n    - <…>\n\n    Mark “[[FIGURE+number or letter]]” wherever a figure from the paper should be placed (we’ll move it later).\n    Do not include any other words, symbols, or slide numbers.\n\n    Paper:\n    {text[:10000]}  # truncate to avoid token overflow\n    \"\"\"\n    response = client.models.generate_content(model=model, contents= prompt)\n    return response.text", "imports": [], "class_name": null, "function_name": "generate_slide_content", "docstring": null, "variables": ["response", "prompt"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What parameters does generate_slide_content accept?", "answer": "Here's the implementation:\n```python\ndef generate_slide_content(text: str, model='gemini-2.0-flash') -> str:\n    prompt = f\"\"\"\n    You are an expert scientific summarizer.\n    Summarize the following academic paper into no more than **{num_slides}** clean PowerPoint slides.\n    You are welcome to use less slides. \n    More advanced expert can use less slides and less bullets to cover key points.\n    For each slide output exactly:\n\n    Slide 1:\n    Title: <one short sentence>\n    Bullets:\n    - <up to 5 bullets, max 16 words each>\n    - <…>\n    - <…>\n\n    Mark “[[FIGURE+number or letter]]” wherever a figure from the paper should be placed (we’ll move it later).\n    Do not include any other words, symbols, or slide numbers.\n\n    Paper:\n    {text[:10000]}  # truncate to avoid token overflow\n    \"\"\"\n    response = client.models.generate_content(model=model, contents= prompt)\n    return response.text\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: generate_slide_content", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 69, "end_line": 91, "code": "def generate_slide_content(text: str, model='gemini-2.0-flash') -> str:\n    prompt = f\"\"\"\n    You are an expert scientific summarizer.\n    Summarize the following academic paper into no more than **{num_slides}** clean PowerPoint slides.\n    You are welcome to use less slides. \n    More advanced expert can use less slides and less bullets to cover key points.\n    For each slide output exactly:\n\n    Slide 1:\n    Title: <one short sentence>\n    Bullets:\n    - <up to 5 bullets, max 16 words each>\n    - <…>\n    - <…>\n\n    Mark “[[FIGURE+number or letter]]” wherever a figure from the paper should be placed (we’ll move it later).\n    Do not include any other words, symbols, or slide numbers.\n\n    Paper:\n    {text[:10000]}  # truncate to avoid token overflow\n    \"\"\"\n    response = client.models.generate_content(model=model, contents= prompt)\n    return response.text", "imports": [], "class_name": null, "function_name": "generate_slide_content", "docstring": null, "variables": ["response", "prompt"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What are the edge cases for generate_slide_content?", "answer": "Here's the implementation:\n```python\ndef generate_slide_content(text: str, model='gemini-2.0-flash') -> str:\n    prompt = f\"\"\"\n    You are an expert scientific summarizer.\n    Summarize the following academic paper into no more than **{num_slides}** clean PowerPoint slides.\n    You are welcome to use less slides. \n    More advanced expert can use less slides and less bullets to cover key points.\n    For each slide output exactly:\n\n    Slide 1:\n    Title: <one short sentence>\n    Bullets:\n    - <up to 5 bullets, max 16 words each>\n    - <…>\n    - <…>\n\n    Mark “[[FIGURE+number or letter]]” wherever a figure from the paper should be placed (we’ll move it later).\n    Do not include any other words, symbols, or slide numbers.\n\n    Paper:\n    {text[:10000]}  # truncate to avoid token overflow\n    \"\"\"\n    response = client.models.generate_content(model=model, contents= prompt)\n    return response.text\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: generate_slide_content", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 69, "end_line": 91, "code": "def generate_slide_content(text: str, model='gemini-2.0-flash') -> str:\n    prompt = f\"\"\"\n    You are an expert scientific summarizer.\n    Summarize the following academic paper into no more than **{num_slides}** clean PowerPoint slides.\n    You are welcome to use less slides. \n    More advanced expert can use less slides and less bullets to cover key points.\n    For each slide output exactly:\n\n    Slide 1:\n    Title: <one short sentence>\n    Bullets:\n    - <up to 5 bullets, max 16 words each>\n    - <…>\n    - <…>\n\n    Mark “[[FIGURE+number or letter]]” wherever a figure from the paper should be placed (we’ll move it later).\n    Do not include any other words, symbols, or slide numbers.\n\n    Paper:\n    {text[:10000]}  # truncate to avoid token overflow\n    \"\"\"\n    response = client.models.generate_content(model=model, contents= prompt)\n    return response.text", "imports": [], "class_name": null, "function_name": "generate_slide_content", "docstring": null, "variables": ["response", "prompt"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What are the edge cases for clean_bullet?", "answer": "Here's the implementation:\n```python\ndef clean_bullet(line):\n    # drop everything after MAX_WORDS_PER_BULLET words\n    words = line.strip().split()\n    return ' '.join(words[:MAX_WORDS_PER_BULLET])\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: clean_bullet", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 96, "end_line": 99, "code": "def clean_bullet(line):\n    # drop everything after MAX_WORDS_PER_BULLET words\n    words = line.strip().split()\n    return ' '.join(words[:MAX_WORDS_PER_BULLET])", "imports": [], "class_name": null, "function_name": "clean_bullet", "docstring": null, "variables": ["words"]}, "question_type": "function", "difficulty": "hard", "metadata": null}
{"question": "How would you test clean_bullet?", "answer": "Here's the implementation:\n```python\ndef clean_bullet(line):\n    # drop everything after MAX_WORDS_PER_BULLET words\n    words = line.strip().split()\n    return ' '.join(words[:MAX_WORDS_PER_BULLET])\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: clean_bullet", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 96, "end_line": 99, "code": "def clean_bullet(line):\n    # drop everything after MAX_WORDS_PER_BULLET words\n    words = line.strip().split()\n    return ' '.join(words[:MAX_WORDS_PER_BULLET])", "imports": [], "class_name": null, "function_name": "clean_bullet", "docstring": null, "variables": ["words"]}, "question_type": "function", "difficulty": "hard", "metadata": null}
{"question": "What are the side effects of calling clean_bullet?", "answer": "Here's the implementation:\n```python\ndef clean_bullet(line):\n    # drop everything after MAX_WORDS_PER_BULLET words\n    words = line.strip().split()\n    return ' '.join(words[:MAX_WORDS_PER_BULLET])\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: clean_bullet", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 96, "end_line": 99, "code": "def clean_bullet(line):\n    # drop everything after MAX_WORDS_PER_BULLET words\n    words = line.strip().split()\n    return ' '.join(words[:MAX_WORDS_PER_BULLET])", "imports": [], "class_name": null, "function_name": "clean_bullet", "docstring": null, "variables": ["words"]}, "question_type": "function", "difficulty": "easy", "metadata": null}
{"question": "What is the time complexity of create_ppt?", "answer": "Here's the implementation:\n```python\ndef create_ppt(slide_text, filename):\n    prs = Presentation()\n    slides = slide_text.strip().split(\"Slide\")[1:]  # crude splitter, improve in the future\n    for i, slide in enumerate(slides[:5], 1):  # force max 5 slides\n        # parse\n        lines = [l.strip() for l in slide.splitlines() if l.strip()]\n        bullets = []\n        for l in lines:\n            if l.startswith(\"-\"):\n                b = l.lstrip(\"- \").strip()  # bullets are the lines start with '- '\n                bullets.append(clean_bullet(b))\n            elif l.startswith('Title: '):  # title is the line starts with 'Title: '\n                title = l.lstrip('Title: ').strip()\n            if len(bullets) >= MAX_BULLETS:\n                break\n    \n        # build slide\n        layout = prs.slide_layouts[1]  # title+content\n        s = prs.slides.add_slide(layout)\n        s.shapes.title.text = title\n        tf = s.placeholders[1].text_frame\n        for b in bullets:\n            p = tf.add_paragraph()\n            p.text = b\n            p.font.size = Pt(18)\n\n    prs.save(filename)\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: create_ppt", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 101, "end_line": 127, "code": "def create_ppt(slide_text, filename):\n    prs = Presentation()\n    slides = slide_text.strip().split(\"Slide\")[1:]  # crude splitter, improve in the future\n    for i, slide in enumerate(slides[:5], 1):  # force max 5 slides\n        # parse\n        lines = [l.strip() for l in slide.splitlines() if l.strip()]\n        bullets = []\n        for l in lines:\n            if l.startswith(\"-\"):\n                b = l.lstrip(\"- \").strip()  # bullets are the lines start with '- '\n                bullets.append(clean_bullet(b))\n            elif l.startswith('Title: '):  # title is the line starts with 'Title: '\n                title = l.lstrip('Title: ').strip()\n            if len(bullets) >= MAX_BULLETS:\n                break\n    \n        # build slide\n        layout = prs.slide_layouts[1]  # title+content\n        s = prs.slides.add_slide(layout)\n        s.shapes.title.text = title\n        tf = s.placeholders[1].text_frame\n        for b in bullets:\n            p = tf.add_paragraph()\n            p.text = b\n            p.font.size = Pt(18)\n\n    prs.save(filename)", "imports": [], "class_name": null, "function_name": "create_ppt", "docstring": null, "variables": ["slides", "s", "b", "i", "l", "bullets", "layout", "tf", "title", "p", "lines", "slide", "prs"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
{"question": "What is the return type of create_ppt?", "answer": "Here's the implementation:\n```python\ndef create_ppt(slide_text, filename):\n    prs = Presentation()\n    slides = slide_text.strip().split(\"Slide\")[1:]  # crude splitter, improve in the future\n    for i, slide in enumerate(slides[:5], 1):  # force max 5 slides\n        # parse\n        lines = [l.strip() for l in slide.splitlines() if l.strip()]\n        bullets = []\n        for l in lines:\n            if l.startswith(\"-\"):\n                b = l.lstrip(\"- \").strip()  # bullets are the lines start with '- '\n                bullets.append(clean_bullet(b))\n            elif l.startswith('Title: '):  # title is the line starts with 'Title: '\n                title = l.lstrip('Title: ').strip()\n            if len(bullets) >= MAX_BULLETS:\n                break\n    \n        # build slide\n        layout = prs.slide_layouts[1]  # title+content\n        s = prs.slides.add_slide(layout)\n        s.shapes.title.text = title\n        tf = s.placeholders[1].text_frame\n        for b in bullets:\n            p = tf.add_paragraph()\n            p.text = b\n            p.font.size = Pt(18)\n\n    prs.save(filename)\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: create_ppt", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 101, "end_line": 127, "code": "def create_ppt(slide_text, filename):\n    prs = Presentation()\n    slides = slide_text.strip().split(\"Slide\")[1:]  # crude splitter, improve in the future\n    for i, slide in enumerate(slides[:5], 1):  # force max 5 slides\n        # parse\n        lines = [l.strip() for l in slide.splitlines() if l.strip()]\n        bullets = []\n        for l in lines:\n            if l.startswith(\"-\"):\n                b = l.lstrip(\"- \").strip()  # bullets are the lines start with '- '\n                bullets.append(clean_bullet(b))\n            elif l.startswith('Title: '):  # title is the line starts with 'Title: '\n                title = l.lstrip('Title: ').strip()\n            if len(bullets) >= MAX_BULLETS:\n                break\n    \n        # build slide\n        layout = prs.slide_layouts[1]  # title+content\n        s = prs.slides.add_slide(layout)\n        s.shapes.title.text = title\n        tf = s.placeholders[1].text_frame\n        for b in bullets:\n            p = tf.add_paragraph()\n            p.text = b\n            p.font.size = Pt(18)\n\n    prs.save(filename)", "imports": [], "class_name": null, "function_name": "create_ppt", "docstring": null, "variables": ["slides", "s", "b", "i", "l", "bullets", "layout", "tf", "title", "p", "lines", "slide", "prs"]}, "question_type": "function", "difficulty": "easy", "metadata": null}
{"question": "How does create_ppt work?", "answer": "Here's the implementation:\n```python\ndef create_ppt(slide_text, filename):\n    prs = Presentation()\n    slides = slide_text.strip().split(\"Slide\")[1:]  # crude splitter, improve in the future\n    for i, slide in enumerate(slides[:5], 1):  # force max 5 slides\n        # parse\n        lines = [l.strip() for l in slide.splitlines() if l.strip()]\n        bullets = []\n        for l in lines:\n            if l.startswith(\"-\"):\n                b = l.lstrip(\"- \").strip()  # bullets are the lines start with '- '\n                bullets.append(clean_bullet(b))\n            elif l.startswith('Title: '):  # title is the line starts with 'Title: '\n                title = l.lstrip('Title: ').strip()\n            if len(bullets) >= MAX_BULLETS:\n                break\n    \n        # build slide\n        layout = prs.slide_layouts[1]  # title+content\n        s = prs.slides.add_slide(layout)\n        s.shapes.title.text = title\n        tf = s.placeholders[1].text_frame\n        for b in bullets:\n            p = tf.add_paragraph()\n            p.text = b\n            p.font.size = Pt(18)\n\n    prs.save(filename)\n```\n\nThe function appears to be defined with the following signature:\n\n- File: D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py\n\n- Function: create_ppt", "context": {"file_path": "D:\\Application\\ai_learn\\llm\\paper2presentation\\pdf2ppt.py", "start_line": 101, "end_line": 127, "code": "def create_ppt(slide_text, filename):\n    prs = Presentation()\n    slides = slide_text.strip().split(\"Slide\")[1:]  # crude splitter, improve in the future\n    for i, slide in enumerate(slides[:5], 1):  # force max 5 slides\n        # parse\n        lines = [l.strip() for l in slide.splitlines() if l.strip()]\n        bullets = []\n        for l in lines:\n            if l.startswith(\"-\"):\n                b = l.lstrip(\"- \").strip()  # bullets are the lines start with '- '\n                bullets.append(clean_bullet(b))\n            elif l.startswith('Title: '):  # title is the line starts with 'Title: '\n                title = l.lstrip('Title: ').strip()\n            if len(bullets) >= MAX_BULLETS:\n                break\n    \n        # build slide\n        layout = prs.slide_layouts[1]  # title+content\n        s = prs.slides.add_slide(layout)\n        s.shapes.title.text = title\n        tf = s.placeholders[1].text_frame\n        for b in bullets:\n            p = tf.add_paragraph()\n            p.text = b\n            p.font.size = Pt(18)\n\n    prs.save(filename)", "imports": [], "class_name": null, "function_name": "create_ppt", "docstring": null, "variables": ["slides", "s", "b", "i", "l", "bullets", "layout", "tf", "title", "p", "lines", "slide", "prs"]}, "question_type": "function", "difficulty": "medium", "metadata": null}
